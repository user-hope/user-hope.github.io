---
headerDepth: 4
prev:
  link: /pages/web-server/odoo/section-02/国际化.md
next:
  link: /pages/web-server/odoo/section-02/继承.md
---

## 继承

Odoo 的一项强大之处是无需直接修改所扩展模块的代码即可添加功能, 这都归功于与自身代码组件相独立的功能继承; 对模块的扩展可通过继承机制实现, 以已有对象的修改层的形式; 这些修改可以发生在每个层面, 包括模型、视图和业务逻辑层面; 我们不是直接修改原有模块, 而是新建一个模块, 采用所要做的修改在已有模块上新增一层;

不论是后端模型还是前端的 `Widget`, 抑或是组成报表的 `Qweb` 和视图, 我们推荐的核心原则就是能在不动原生源码的情况下, 就不要动原生的代码. 这可以说是 `Odoo` 开发中的最佳实践之一;

在前面的 `Mixin` 里面, 其实就是用到的模块的继承来实现的, 可以看成是一种原地修改的扩展, 这是最常用的一种方式, 但 `Odoo` 框架还支持适用其它场景下几种继承机制;

### 经典继承

这是最常见的继承方式, 在已有的模型上添加新的字段或者覆盖原有的方法. 在模型中只需要使用 `_inherit` 并指定要继承的模型名, 然后在 `fields` 或者 `methods` 里面添加或者覆盖需要的部分. 这种方式通常用于已有模型上添加新的功能或者修改原有功能;

```python
class InheritedClass(models.Model):
    _inherit = 'base.model'

    new_field = fields.Char(string='New Field')
```
主要是用于添加或修改已经存在的模型; 这种方法在实际的数据库中还是操作的同一张表, 对表字段进行扩展; 也是最常用的方式, 例如我们需要在原有的 `res.partner` 上面扩展 odoo 原生 `res.partner` 的功能:

```python
from odoo import fields, api, models


class ResPartner(models.Model):
    _inherit = "res.partner"

    branch_code = fields.Char("Branch Code", default='000', compute='_compute_branch_code', store=True)
    first_name = fields.Char("First Name")
    middle_name = fields.Char("Middle Name")
    last_name = fields.Char("Last Name")

    @api.model
    def _commercial_fields(self):
        return super()._commercial_fields() + ['branch_code']
```
`_inherit` 接受一个字符串作为参数时, 表示单一继承, 即当前模型继承自指定的单一模型;  还可以使用 `list` 参数, 表示多继承, 即当前模型同时继承自数组中列举的多个模型, 这使得模型可以同时继承多种模型的属性和行为;

```python

class MassMailing(models.Model):
    _name = 'mailing.mailing'
    _description = 'Mass Mailing'
    _inherit = [
        'mail.thread',
        'mail.activity.mixin',
        'mail.render.mixin',
        'utm.source.mixin'
    ]
    _order = 'calendar_date DESC'
    _rec_name = "subject"
```

### 委派继承

这是一种特殊的继承方式, 被委派的模型会有一个指向父模型的关联字段. 它的主要作用是将某个模型的部分功能"委托"给另一个模型, 这种方式的继承在数据库层面上添加了一个新的表. 当你想要创建一个新的模型, 但又希望保持某个模型的所有字段和行为时, 这种继承方式非常有用;

```python
class Users(models.Model):

    _name = "res.users"
    _description = 'User'
    _inherits = {'res.partner': 'partner_id'}
    
    partner_id = fields.Many2one('res.partner', required=True, ondelete='restrict', auto_join=True, index=True, string='Related Partner')
    
    
class ProductProduct(models.Model):
    _name = "product.product"
    _description = "Product Variant"
    _inherits = {'product.template': 'product_tmpl_id'}
    
    product_tmpl_id = fields.Many2one('product.template', 'Product Template', auto_join=True, index=True, ondelete="cascade", required=True)
```
委派继承用于包含已经存在的模型的情况, 如你需要新模型具有已经存在的模型的所有字段和行为;

这种方式会创建一个新的表, 必须包含一个 `Many2one` 的字段, 指向被继承的对象, 当其中任何一方的值发生变化的时候, 都会同步到另一方中; 

odoo 典型的应用就是官方模块中的产品模板与产品的关系, 在 `Odoo` 原生模块中, 有一个对象叫做 `product.template`, 指的是一系列产品的通用模板属性; 而在销售、采购和仓储的实际运用中, 使用的是叫 `product.product` 的对象, 这个才是真正的产品;  `product.product` 和 `product.template` 的关系就是我们上面所说的属性继承的关系; `product.product` 中一个 `many2one` 的字段 `product_tmpl_id` 关联的就是 `product.template`, 当 `product.template` 中的属性发生变化时, 没有被重写(注意: `product.product` 对象中有些字段覆盖了 `product.template` 中的字段)的属性就会跟着变化; 形成了一种有趣的引用关系;

### 原型继承

这也是一种特殊的继承方式, 在数据库层面它实际上是新建一个与继承的模型相同的模型 (名称不同). 尽管两个模型在数据库中存在于不同的表, 但是从 Odoo 的角度看, 它们就是一个模型, 这就意味着除了名称, 新模型的所有其他属性都会与原模型相同. 这种方式的继承在需要一个修改过的模型副本, 但是又不想改变原始模型时非常有用;

```python
class InheritedClass(models.Model):
    _name = 'new.model'
    _inherit = 'base.model'
```

原型继承用于你需要一个已经存在的模型的复制, 并且希望这个复制在数据库中是独立存在的;

经典继承使用 `_inherit` 属性扩展模型, 因其未修改 `_name` 属性, 可对该模型执行有效的原地变更; 如果使用 `_inherit` 的同时修改了 `_name` 属性, 就会获得一具所继承模型的副本;














